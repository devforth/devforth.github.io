"use strict";(self.webpackChunkadminforth=self.webpackChunkadminforth||[]).push([[4647],{42459:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>o,contentTitle:()=>r,default:()=>p,frontMatter:()=>i,metadata:()=>l,toc:()=>c});var s=a(74848),t=a(28453);const i={slug:"k3s-ec2-deployment",title:"IaC Simplified: K3s on EC2 Deployments with Terraform, Helm, Ansible & Amazon ECR",authors:"kirilldorr",tags:["aws","terraform","helm","k3s","ansible"],description:"The ultimate step-by-step guide to cost-effective, build-time-efficient, and easy managable EC2 deployments using K3s, Terraform, Helm, Ansible, and a Amazon ECR registry."},r=void 0,l={permalink:"/blog/k3s-ec2-deployment",source:"@site/blog/2025-11-04-k3s-ec2-deployment/index.md",title:"IaC Simplified: K3s on EC2 Deployments with Terraform, Helm, Ansible & Amazon ECR",description:"The ultimate step-by-step guide to cost-effective, build-time-efficient, and easy managable EC2 deployments using K3s, Terraform, Helm, Ansible, and a Amazon ECR registry.",date:"2025-11-04T00:00:00.000Z",tags:[{inline:!1,label:"AWS",permalink:"/blog/tags/aws",description:"Amazon Web Services (AWS) is a cloud computing platform that provides a wide range of services for building and deploying applications."},{inline:!1,label:"Terraform",permalink:"/blog/tags/terraform",description:"Terraform is an open-source infrastructure as code software tool created by HashiCorp that enables users to define and provision data center infrastructure using a declarative configuration language."},{inline:!1,label:"Helm",permalink:"/blog/tags/helm",description:"The package manager for Kubernetes"},{inline:!1,label:"k3s",permalink:"/blog/tags/k3s",description:"k3s is a lightweight version of k8s (kubernetes) that is also used for container orchestration but uses fewer resources."},{inline:!1,label:"Ansible",permalink:"/blog/tags/ansible",description:"Ansible is an open-source automation tool used for configuration management, application deployment, and task automation."}],readingTime:13.115,hasTruncateMarker:!0,authors:[{name:"Kyrylo Doropii",title:"DevOps Engineer of AdminForth",url:"https://github.com/kirilldorr",imageURL:"https://avatars.githubusercontent.com/u/181721742?s=96&v=4",key:"kirilldorr"}],frontMatter:{slug:"k3s-ec2-deployment",title:"IaC Simplified: K3s on EC2 Deployments with Terraform, Helm, Ansible & Amazon ECR",authors:"kirilldorr",tags:["aws","terraform","helm","k3s","ansible"],description:"The ultimate step-by-step guide to cost-effective, build-time-efficient, and easy managable EC2 deployments using K3s, Terraform, Helm, Ansible, and a Amazon ECR registry."},unlisted:!1,nextItem:{title:"How to set up Context7 MCP in Visual Studio Code",permalink:"/blog/context7-setup-vscode"}},o={authorsImageUrls:[void 0]},c=[{value:"Why exactly K3s?",id:"why-exactly-k3s",level:2},{value:"How we will store containers?",id:"how-we-will-store-containers",level:2},{value:"Step 1 - create a SSH keypair",id:"step-1---create-a-ssh-keypair",level:2},{value:"Step 2 - .gitignore file",id:"step-2---gitignore-file",level:2},{value:"Step 3 - Terraform folder",id:"step-3---terraform-folder",level:2},{value:"Step 4 - Helm",id:"step-4---helm",level:3},{value:"Step 5 - Provider Helm",id:"step-5---provider-helm",level:3},{value:"Step 6 - Ansible",id:"step-6---ansible",level:3},{value:"Step 7 - Configure AWS Profile",id:"step-7---configure-aws-profile",level:3},{value:"Step 8 - Run deployment",id:"step-8---run-deployment",level:3},{value:"All done!",id:"all-done",level:3}];function d(e){const n={a:"a",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:"This guide shows how to deploy own Docker apps (with AdminForth as example) to Amazon EC2 instance with K3s and Terraform involving pushing images into Amazon ECR."}),"\n",(0,s.jsx)(n.p,{children:"Needed resources:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["AWS account where we will auto-spawn EC2 instance. We will use ",(0,s.jsx)(n.code,{children:"t3a.small"})," instance (2 vCPUs, 2GB RAM) which costs ",(0,s.jsx)(n.code,{children:"~14$"})," per month in ",(0,s.jsx)(n.code,{children:"us-west-2"})," region (cheapest region). Also it will take ",(0,s.jsx)(n.code,{children:"$2"})," per month for EBS gp2 storage (20GB) for EC2 instance."]}),"\n",(0,s.jsxs)(n.li,{children:["Also AWS ECR will charge for ",(0,s.jsx)(n.code,{children:"$0.09"})," per GB of data egress traffic (from EC2 to the internet) - this needed to load docker build cache."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"The setup shape:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Build is done using IaaC approach with HashiCorp Terraform, so almoast no manual actions are needed from you. Every resource including EC2 server instance is described in code which is commited to repo."}),"\n",(0,s.jsx)(n.li,{children:"Docker images and build cache are stored on Amazon ECR"}),"\n",(0,s.jsx)(n.li,{children:"Total build time for average commit to AdminForth app (with Vite rebuilds) is around 3 minutes."}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"why-exactly-k3s",children:"Why exactly K3s?"}),"\n",(0,s.jsx)(n.p,{children:"Previously, our blog featured posts about different types of application deployment, but without the use of Kubernetes. This post will look at the cheapest option for deploying an application using k3s (a lightweight version of k8s Kubernetes). This option is more interesting than most of the alternatives, primarily because of its automation and scalability (it is, of course, inferior to the \u201colder\u201d K8s, but it also requires significantly fewer resources)."}),"\n",(0,s.jsx)(n.h2,{id:"how-we-will-store-containers",children:"How we will store containers?"}),"\n",(0,s.jsx)(n.p,{children:"The ECR repository will be used for storage. Since we are working with AWS, this is the most reliable option. The image must be assembled from local files on the machine and then sent to the Amazon server. All instructions for performing these actions will be provided below."}),"\n",(0,s.jsx)(n.h1,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,s.jsx)(n.p,{children:"I will assume you run Ubuntu (Native or WSL2)."}),"\n",(0,s.jsx)(n.p,{children:"You should have terraform, here is official repository:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'wget -O - https://apt.releases.hashicorp.com/gpg | sudo gpg --dearmor -o /usr/share/keyrings/hashicorp-archive-keyring.gpg\necho "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/hashicorp-archive-keyring.gpg] https://apt.releases.hashicorp.com $(lsb_release -cs) main" | sudo tee /etc/apt/sources.list.d/hashicorp.list\nsudo apt update && sudo apt install terraform\n'})}),"\n",(0,s.jsx)(n.p,{children:"AWS CLI:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"sudo snap install aws-cli --classic\n"})}),"\n",(0,s.jsx)(n.p,{children:"HELM:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"curl -fsSL -o get_helm.sh https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-4\nchmod 700 get_helm.sh\n./get_helm.sh\n"})}),"\n",(0,s.jsx)(n.p,{children:"Also you need Doker Daemon running. We recommend Docker Desktop running. ON WSL2 make sure you have Docker Desktop WSL2 integration enabled."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"docker version\n"})}),"\n",(0,s.jsxs)(n.p,{children:["It is also worth having ",(0,s.jsx)(n.code,{children:"kubectl"})," locally on your machine for more convenient interaction with nodes and pods, but this is not mandatory."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:'curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"\n'})}),"\n",(0,s.jsx)(n.p,{children:"Last step is download ansible:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"sudo add-apt-repository --yes --update ppa:ansible/ansible\nsudo apt install ansible -y\n\n"})}),"\n",(0,s.jsx)(n.h1,{id:"practice---deploy-setup",children:"Practice - deploy setup"}),"\n",(0,s.jsxs)(n.p,{children:["Assume you have your AdminForth project in ",(0,s.jsx)(n.code,{children:"myadmin"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"step-1---create-a-ssh-keypair",children:"Step 1 - create a SSH keypair"}),"\n",(0,s.jsxs)(n.p,{children:["Make sure you are still in ",(0,s.jsx)(n.code,{children:"deploy"})," folder, run next command:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",metastring:'title="deploy"',children:'mkdir .keys && ssh-keygen -f .keys/id_rsa -N ""\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Now it should create ",(0,s.jsx)(n.code,{children:"deploy/.keys/id_rsa"})," and ",(0,s.jsx)(n.code,{children:"deploy/.keys/id_rsa.pub"})," files with your SSH keypair. Terraform script will put the public key to the EC2 instance and will use private key to connect to the instance. Also you will be able to use it to connect to the instance manually."]}),"\n",(0,s.jsx)(n.h2,{id:"step-2---gitignore-file",children:"Step 2 - .gitignore file"}),"\n",(0,s.jsxs)(n.p,{children:["Create ",(0,s.jsx)(n.code,{children:"deploy/.gitignore"})," file with next content:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:".terraform/\n.keys/\n*.tfstate\n*.tfstate.*\n*.tfvars\ntfplan\nsession-manager-plugin.deb\n.terraform.lock.hcl\n"})}),"\n",(0,s.jsx)(n.h2,{id:"step-3---terraform-folder",children:"Step 3 - Terraform folder"}),"\n",(0,s.jsxs)(n.p,{children:["First of all install Terraform as described here ",(0,s.jsx)(n.a,{href:"https://developer.hashicorp.com/terraform/install#linux",children:"terraform installation"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"After this create folder ../deploy/terraform"}),"\n",(0,s.jsxs)(n.p,{children:["Create file ",(0,s.jsx)(n.code,{children:"main.tf"})," in ",(0,s.jsx)(n.code,{children:"deploy/terraform"})," folder:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-hcl",metastring:'title="deploy/terraform/main.tf"',children:'terraform {\n  required_providers {\n    aws = {\n      source  = "hashicorp/aws"\n      version = "~> 5.0"\n    }\n  }\n\n}\n\nlocals {\n  aws_region           = "us-west-2"\n  vpc_cidr             = "10.0.0.0/16"\n  subnet_a_cidr        = "10.0.10.0/24"\n  subnet_b_cidr        = "10.0.11.0/24"\n  az_a                 = "us-west-2a"\n  az_b                 = "us-west-2b"\n  app_name             = <your_app_name>\n  app_source_code_path = "../../"\n  ansible_dir          = "../ansible/playbooks"\n  app_files            = fileset(local.app_source_code_path, "**")\n\n  image_tag = sha256(join("", [\n    for f in local.app_files :\n    try(filesha256("${local.app_source_code_path}/${f}"), "")\n    if length(regexall("^deploy/", f)) == 0\n    && length(regexall("^\\\\.vscode/", f)) == 0\n    && length(regexall("^node_modules/", f)) == 0\n    && length(regexall("^\\\\.gitignore", f)) == 0\n  ]))\n\n  ingress_ports = [\n    { from = 22, to = 22, protocol = "tcp", desc = "SSH" },\n    { from = 80, to = 80, protocol = "tcp", desc = "App HTTP (Traefik)" },\n    { from = 443, to = 443, protocol = "tcp", desc = "App HTTPS (Traefik)" },\n    { from = 6443, to = 6443, protocol = "tcp", desc = "Kubernetes API" }\n  ]\n}\n\nprovider "aws" {\n  region  = local.aws_region\n  profile = "myaws"\n}\n\ndata "aws_ami" "ubuntu_22_04" {\n  most_recent = true\n  owners      = ["099720109477"] # Canonical ubuntu account ID\n\n  filter {\n    name   = "name"\n    values = ["ubuntu/images/hvm-ssd/ubuntu-jammy-22.04-amd64-server-*"]\n  }\n}\n\nresource "aws_key_pair" "app_deployer" {\n  key_name   = "terraform-deploy_${local.app_name}-key"\n  public_key = file("../.keys/id_rsa.pub") # Path to your public SSH key\n}\n\nresource "aws_instance" "ec2_instance" {\n  instance_type = "t3a.small"\n  ami           = data.aws_ami.ubuntu_22_04.id\n\n  iam_instance_profile = aws_iam_instance_profile.instance_profile.name\n\n  subnet_id                   = aws_subnet.public_a.id\n  vpc_security_group_ids      = [aws_security_group.app_sg.id]\n  associate_public_ip_address = true\n  key_name                    = aws_key_pair.app_deployer.key_name\n\n  tags = {\n    Name = local.app_name\n  }\n\n  depends_on = [\n    null_resource.docker_build_and_push\n  ]\n\n  # prevent accidental termination of ec2 instance and data loss\n  lifecycle {\n    create_before_destroy = true #uncomment in production\n    #prevent_destroy       = true       #uncomment in production\n    ignore_changes = [ami]\n    replace_triggered_by = [\n      null_resource.docker_build_and_push\n    ]\n  }\n\n  root_block_device {\n    volume_size = 10 // Size in GB for root partition\n    volume_type = "gp2"\n\n    # Even if the instance is terminated, the volume will not be deleted, delete it manually if needed\n    delete_on_termination = true #change to false in production if data persistence is needed\n  }\n\n}\n\n\nresource "local_file" "ansible_inventory" {\n  content = <<EOF\n[k3s_nodes]\n${aws_instance.ec2_instance.public_ip} ansible_user=ubuntu ansible_ssh_private_key_file=../.keys/id_rsa\nEOF\n\n  filename = "../ansible/inventory.ini"\n}\n\nresource "null_resource" "wait_ssh" {\n  depends_on = [aws_instance.ec2_instance]\n\n  triggers = (\n    {\n      instance_id = aws_instance.ec2_instance.id\n    }\n  )\n\n  provisioner "local-exec" {\n    command = <<EOT\n    bash -c \'\n    for i in {1..10}; do\n      nc -zv ${aws_instance.ec2_instance.public_ip} 22 && echo "SSH is ready!" && exit 0\n      sleep 5\n    done\n    exit 1\n    \'\n    EOT\n  }\n}\n\nresource "null_resource" "ansible_provision" {\n  depends_on = [\n    aws_instance.ec2_instance,\n    local_file.ansible_inventory,\n    null_resource.wait_ssh,\n    local_file.image_tag\n  ]\n\n  triggers = {\n    instance_id = aws_instance.ec2_instance.id\n  }\n\n  provisioner "local-exec" {\n    interpreter = ["/bin/bash", "-c"]\n\n    command = <<-EOT\n      set -e\n      ANSIBLE_HOST_KEY_CHECKING=False ansible-galaxy collection install community.kubernetes\n      ANSIBLE_HOST_KEY_CHECKING=False ansible-playbook -i ${path.module}/../ansible/inventory.ini ${local.ansible_dir}/playbook.yaml \n    EOT\n  }\n}\n\n'})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["\ud83d\udc46 Replace ",(0,s.jsx)(n.code,{children:"<your_app_name>"})," with your app name (no spaces, only underscores or letters)"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["We will also need a file ",(0,s.jsx)(n.code,{children:"container.tf"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-hcl",metastring:'title="deploy/terraform/container.tf"',children:'\nresource "aws_ecr_repository" "app_repo" {\n  name = local.app_name\n\n  image_tag_mutability = "MUTABLE"\n  image_scanning_configuration {\n    scan_on_push = true\n  }\n  force_delete = true\n}\n\ndata "aws_caller_identity" "current" {}\n\nresource "null_resource" "docker_build_and_push" {\n  depends_on = [aws_ecr_repository.app_repo]\n\n  triggers = {\n    image_tag = local.image_tag\n  }\n\n  provisioner "local-exec" {\n    command = <<-EOT\n      set -e\n      unset DOCKER_HOST\n\n      REPO_URL="${aws_ecr_repository.app_repo.repository_url}"\n      ACCOUNT_ID="${data.aws_caller_identity.current.account_id}"\n      REGION="${local.aws_region}"\n      TAG="${local.image_tag}"\n\n      echo "LOG: Logging in to ECR..."\n      aws ecr get-login-password --region $${REGION} | docker login --username AWS --password-stdin $${ACCOUNT_ID}.dkr.ecr.$${REGION}.amazonaws.com\n      \n      echo "LOG: Building Docker image..."\n      docker build --pull -t $${REPO_URL}:$${TAG} ${local.app_source_code_path}\n\n      echo "LOG: Pushing image to ECR..."\n      docker push $${REPO_URL}:$${TAG}\n\n      echo "LOG: Build and push complete. TAG=$${TAG}"\n    EOT\n\n    interpreter = ["/bin/bash", "-c"]\n  }\n}\n\nresource "local_file" "image_tag" {\n  depends_on = [null_resource.docker_build_and_push]\n  content    = local.image_tag\n  filename   = "${path.module}/image_tag.txt"\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"This file contains a script that builds the Docker image locally. This is done for more flexible deployment. When changing the program code, there is no need to manually update the image on EC2 or in the repository. It is updated automatically with each terraform apply. Below is a table showing the time it takes to build this image from scratch and with minimal changes."}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Feature"}),(0,s.jsx)(n.th,{children:"Time"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Initial build time*"}),(0,s.jsx)(n.td,{children:"0m45.445s"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Rebuild time (changed index.ts)*"}),(0,s.jsx)(n.td,{children:"0m26.757s"})]})]})]}),"\n",(0,s.jsx)("sub",{children:"* All tests done from local machine (Intel(R) Core(TM) i7 9760H, Docker Desktop/Ubuntu 32 GB RAM, 300Mbps up/down) up to working state"}),"\n",(0,s.jsxs)(n.p,{children:["Also, ",(0,s.jsx)(n.code,{children:"resvpc.tf"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-hcl",metastring:'title="deploy/terraform/resvpc.tf"',children:'resource "aws_vpc" "main" {\n  cidr_block = local.vpc_cidr\n\n  enable_dns_support   = true\n  enable_dns_hostnames = true\n\n  tags = { Name = "main-vpc" }\n}\n\nresource "aws_subnet" "public_a" {\n  vpc_id                  = aws_vpc.main.id\n  cidr_block              = local.subnet_a_cidr\n  map_public_ip_on_launch = true\n  availability_zone       = local.az_a\n  tags = {\n    Name = "public-a"\n  }\n}\n\nresource "aws_subnet" "public_b" {\n  vpc_id                  = aws_vpc.main.id\n  cidr_block              = local.subnet_b_cidr\n  map_public_ip_on_launch = true\n  availability_zone       = local.az_b\n  tags = {\n    Name = "public-b"\n  }\n}\n\nresource "aws_internet_gateway" "igw" {\n  vpc_id = aws_vpc.main.id\n  tags   = { Name = "main-igw" }\n}\n\nresource "aws_route_table" "public_rt" {\n  vpc_id = aws_vpc.main.id\n  route {\n    cidr_block = "0.0.0.0/0"\n    gateway_id = aws_internet_gateway.igw.id\n  }\n  tags = { Name = "public-rt" }\n}\n\nresource "aws_route_table_association" "public_a_assoc" {\n  subnet_id      = aws_subnet.public_a.id\n  route_table_id = aws_route_table.public_rt.id\n}\n\nresource "aws_route_table_association" "public_b_assoc" {\n  subnet_id      = aws_subnet.public_b.id\n  route_table_id = aws_route_table.public_rt.id\n}\n\nresource "aws_security_group" "app_sg" {\n  name   = "${local.app_name}-SecurityGroup"\n  vpc_id = aws_vpc.main.id\n\n  dynamic "ingress" {\n    for_each = local.ingress_ports\n    content {\n      from_port   = ingress.value.from\n      to_port     = ingress.value.to\n      protocol    = ingress.value.protocol\n      cidr_blocks = ["0.0.0.0/0"]\n      description = ingress.value.desc\n    }\n  }\n\n  egress {\n    from_port   = 0\n    to_port     = 0\n    protocol    = "-1"\n    cidr_blocks = ["0.0.0.0/0"]\n  }\n}\n\nresource "aws_iam_role" "node_role" {\n  name = "${local.app_name}node-role"\n  assume_role_policy = jsonencode({\n    Version = "2012-10-17"\n    Statement = [{\n      Effect    = "Allow"\n      Principal = { Service = "ec2.amazonaws.com" }\n      Action    = "sts:AssumeRole"\n    }]\n  })\n}\n\nresource "aws_iam_role_policy_attachment" "ecr_read_only_attach" {\n  policy_arn = "arn:aws:iam::aws:policy/AmazonEC2ContainerRegistryReadOnly"\n  role       = aws_iam_role.node_role.name\n}\n\nresource "aws_iam_role_policy_attachment" "ssm_core_policy" {\n  policy_arn = "arn:aws:iam::aws:policy/AmazonSSMManagedInstanceCore"\n  role       = aws_iam_role.node_role.name\n}\n\nresource "aws_iam_instance_profile" "instance_profile" {\n  name = "${local.app_name}-instance-profile"\n  role = aws_iam_role.node_role.name\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["And ",(0,s.jsx)(n.code,{children:"outputs.tf"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-hcl",metastring:'title="deploy/terraform/outputs.tf"',children:'output "app_endpoint" {\n  value = "http://${aws_instance.ec2_instance.public_dns}"\n}\n\noutput "ssh_connect_command" {\n  value = "ssh -i .keys/id_rsa ubuntu@${aws_instance.ec2_instance.public_dns}"\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"step-4---helm",children:"Step 4 - Helm"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Helm"})," is a command-line tool and a set of libraries that helps manage applications in Kubernetes."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Helm Chart (Chart)"})," is a package containing everything needed to run an application in Kubernetes. It's the equivalent of ",(0,s.jsx)(n.code,{children:"apt"})," or ",(0,s.jsx)(n.code,{children:"yum"})," packages in Linux."]}),"\n",(0,s.jsx)(n.p,{children:"A chart has this structure:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"helm_charts/\n\u251c\u2500\u2500 Chart.yaml        # Metadata about the chart (name, version)\n\u251c\u2500\u2500 values.yaml       # Default values (configuration)\n\u2514\u2500\u2500 templates/        # Folder with Kubernetes templates (YAML files)\n    \u251c\u2500\u2500 deployment.yaml\n    \u251c\u2500\u2500 service.yaml\n    \u251c\u2500\u2500 ingress.yaml\n    \u2514\u2500\u2500 ...\n"})}),"\n",(0,s.jsx)(n.h3,{id:"step-5---provider-helm",children:"Step 5 - Provider Helm"}),"\n",(0,s.jsx)(n.p,{children:"Now we need to create .../deploy/helm and .../deploy/helm/helm_charts folders"}),"\n",(0,s.jsxs)(n.p,{children:["you need to create a file ",(0,s.jsx)(n.code,{children:"Chart.yaml"})," in it"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",metastring:'title="deploy/helm/helm_charts/Chart.yaml"',children:'apiVersion: v2\nname: myadmink3s # SET YOUR APP NAME\ndescription: Helm chart for myadmin app\nversion: 0.1.0\nappVersion: "1.0.0"\n'})}),"\n",(0,s.jsxs)(n.p,{children:["And ",(0,s.jsx)(n.code,{children:"values.yaml"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",metastring:'title="deploy/helm/helm_charts/values.yaml"',children:'appName: myadmink3s # SET YOUR APP NAME LIKE IN Chart.yaml\nappNameSpace: myadmin # SET YOUR APP NAMESPACE\ncontainerPort: 3500\nservicePort: 80\nadminSecret: "your_secret"\necrImageFull: ""\n'})}),"\n",(0,s.jsx)(n.p,{children:"After this create .../deploy/helm/helm_charts/templates folder"}),"\n",(0,s.jsx)(n.p,{children:"And create files here:"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"deployment.yaml"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",metastring:'title="deploy/helm/helm_charts/templates/deployment.yaml"',children:'apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: {{ .Values.appName }}-deployment\n  namespace: {{ .Values.appNameSpace }}\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: {{ .Values.appName }}\n  template:\n    metadata:\n      labels:\n        app: {{ .Values.appName }}\n    spec:\n      containers:\n      - name: {{ .Values.appName }}\n        image: "{{ .Values.ecrImageFull }}" \n        ports:\n        - containerPort: {{ .Values.containerPort }}\n        env:\n        - name: "ADMINFORTH_SECRET"\n          value: "{{ .Values.adminSecret }}"\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"ingress.yaml"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",metastring:'title="deploy/helm/helm_charts/templates/ingress.yaml"',children:"apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: {{ .Values.appName }}-ingress\n  namespace: {{ .Values.appNameSpace }}\nspec:\n  rules:\n  - http:\n      paths:\n      - path: /\n        pathType: Prefix\n        backend:\n          service:\n            name: {{ .Values.appName }}-service\n            port:\n              number: {{ .Values.servicePort }}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["And ",(0,s.jsx)(n.code,{children:"service.yaml"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",metastring:'title="deploy/helm/helm_charts/templates/service.yaml"',children:"apiVersion: v1\nkind: Service\nmetadata:\n  name: {{ .Values.appName }}-service\n  namespace: {{ .Values.appNameSpace }}\nspec:\n  type: ClusterIP\n  selector:\n    app: {{ .Values.appName }}\n  ports:\n  - port: {{ .Values.servicePort }}\n    targetPort: {{ .Values.containerPort }}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The comments in the ",(0,s.jsx)(n.code,{children:"values.yaml"})," and ",(0,s.jsx)(n.code,{children:"Chart.yaml"})," files indicate the names of the variables that need to be replaced. They must correspond to the variables in Ansible, which will be discussed later."]}),"\n",(0,s.jsx)(n.h3,{id:"step-6---ansible",children:"Step 6 - Ansible"}),"\n",(0,s.jsx)(n.p,{children:"If we explain the logic of deployment, Ansible plays a very important role here. If Terraform is used exclusively to configure cloud infrastructure in AWS, Ansible prepares it for the deployment of a Kubernetes cluster. Ansible Playbooks, in simple terms, are templates for configuring the system (of course, their functionality is much broader, but in this deployment method and in most cases, this is how they are used). That is, after preparing the instance with Terraform, it launches Ansible, which prepares it for the deployment of the Kubernetes cluster, after which it launches Helm.\nThis method allows for the highest quality deployment, because each stage is handled by software specialized for that particular stage."}),"\n",(0,s.jsxs)(n.p,{children:["So, create ",(0,s.jsx)(n.code,{children:"/deploy/ansible/playbooks"})," folder"]}),"\n",(0,s.jsxs)(n.p,{children:["Then the file ",(0,s.jsx)(n.code,{children:"playbook.yaml"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",metastring:'title="/deploy/ansible/playbooks/playbook.yaml"',children:'---\n- name: Deploy application\n  hosts: k3s_nodes\n  become: true\n  vars:\n    k3s_version: "v1.27.3+k3s1"\n    helm_version: "v3.12.3"\n    kubeconfig_path: /etc/rancher/k3s/k3s.yaml\n    helm_url: https://get.helm.sh/helm-v3.12.3-linux-amd64.tar.gz\n    helm_dest: /usr/local/bin/helm\n    app_name: myadmink3s    # <-- CHANGE TO YOUR APP NAME LIKE IN main.tf local.app_name\n    app_namespace: myadmin  # <-- CHANGE TO YOUR APP NAMESPACE\n    aws_account_id: "735356255780" # <-- CHANGE TO YOUR AWS ACCOUNT ID\n    chart_path: /home/ubuntu/{{app_name}}/helm_charts\n\n  tasks:\n\n    - name: Read Docker image tag (local)\n      ansible.builtin.set_fact:\n        image_tag: "{{ lookup(\'file\', \'../../terraform/image_tag.txt\') }}"\n      delegate_to: localhost\n\n    - name: Install unzip\n      ansible.builtin.apt:\n        name: unzip\n        state: present\n        update_cache: true\n\n    - name: Download AWS CLI v2\n      ansible.builtin.get_url:\n        url: "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip"\n        dest: /tmp/awscliv2.zip\n        mode: \'0644\'\n\n    - name: Unzip AWS CLI\n      ansible.builtin.unarchive:\n        src: /tmp/awscliv2.zip\n        dest: /tmp\n        remote_src: true\n\n    - name: Install AWS CLI\n      ansible.builtin.command: /tmp/aws/install --update\n      args:\n        creates: /usr/local/bin/aws\n\n    - name: Update apt cache\n      ansible.builtin.apt:\n        update_cache: true\n\n    - name: Install required packages\n      ansible.builtin.apt:\n        name:\n          - curl\n          - sudo\n          - software-properties-common\n          - apt-transport-https\n          - ca-certificates\n        state: present\n\n    - name: Download k3s installation script\n      ansible.builtin.get_url:\n        url: https://get.k3s.io\n        dest: /tmp/install_k3s.sh\n        mode: \'0700\'\n\n    - name: Install k3s\n      ansible.builtin.command: /tmp/install_k3s.sh\n      environment:\n        INSTALL_K3S_VERSION: "{{ k3s_version }}"\n      args:\n        creates: /usr/local/bin/k3s\n\n    - name: Get ECR token\n      ansible.builtin.command: aws ecr get-login-password --region us-west-2\n      register: ecr_token\n      changed_when: false\n\n    - name: Configure K3s registry for ECR\n      ansible.builtin.copy:\n        dest: /etc/rancher/k3s/registries.yaml\n        content: |\n          configs:\n            "735356255780.dkr.ecr.us-west-2.amazonaws.com":\n              auth:\n                username: AWS\n                password: "{{ ecr_token.stdout }}"\n        mode: \'0600\'\n\n    - name: Restart k3s to apply registry changes\n      ansible.builtin.systemd:\n        name: k3s\n        state: restarted\n        enabled: true\n\n    - name: Wait for k3s node to be ready\n      ansible.builtin.wait_for:\n        path: /usr/local/bin/k3s\n        state: present\n        timeout: 300\n\n    - name: Ensure ~/.kube directory exists\n      ansible.builtin.file:\n        path: /root/.kube\n        state: directory\n        mode: \'0700\'\n\n    - name: Copy k3s kubeconfig\n      ansible.builtin.copy:\n        remote_src: true\n        src: /etc/rancher/k3s/k3s.yaml\n        dest: /root/.kube/config\n        owner: root\n        group: root\n        mode: \'0600\'\n\n    - name: Replace localhost with public IP in kubeconfig\n      ansible.builtin.replace:\n        path: /root/.kube/config\n        regexp: "server: https://127.0.0.1:6443"\n        replace: "server: https://{{ inventory_hostname }}:6443"\n\n    - name: Download Helm tarball\n      ansible.builtin.get_url:\n        url: "https://get.helm.sh/helm-{{ helm_version }}-linux-amd64.tar.gz"\n        dest: "/tmp/helm.tar.gz"\n        mode: \'0644\'\n\n    - name: Extract Helm tarball\n      ansible.builtin.unarchive:\n        src: "/tmp/helm.tar.gz"\n        dest: "/tmp/"\n        remote_src: true\n\n    - name: Move Helm binary to /usr/local/bin\n      ansible.builtin.command:\n        cmd: mv /tmp/linux-amd64/helm /usr/local/bin/helm\n        creates: /usr/local/bin/helm\n\n    - name: Ensure python3-pip is installed\n      ansible.builtin.apt:\n        name: python3-pip\n        state: present\n        update_cache: true\n\n    - name: Install Python kubernetes library\n      ansible.builtin.pip:\n        name: kubernetes\n        executable: pip3\n\n    - name: Extract Helm binary\n      ansible.builtin.unarchive:\n        src: /tmp/helm.tar.gz\n        dest: /tmp\n        remote_src: true\n        extra_opts: [--strip-components=1]\n        creates: /tmp/helm\n\n    - name: Move Helm binary to /usr/local/bin\n      ansible.builtin.command:\n        cmd: mv /tmp/helm /usr/local/bin/helm\n        creates: /usr/local/bin/helm\n\n    - name: Copy Helm chart to server\n      ansible.builtin.copy:\n        src: "../../helm/helm_charts"\n        dest: /home/ubuntu/{{ app_name }}\n        owner: ubuntu\n        group: ubuntu\n        mode: \'0755\'\n        force: true\n\n    - name: Ensure namespace exists - {{ app_namespace }}\n      kubernetes.core.k8s:\n        api_version: v1\n        kind: Namespace\n        name: "{{ app_namespace }}"\n        kubeconfig: "{{ kubeconfig_path }}"\n\n    - name: Deploy stack via Helm - {{ app_name }}\n      kubernetes.core.helm:\n        name: "{{ app_namespace }}"\n        chart_ref: /home/ubuntu/{{ app_name }}/helm_charts\n        release_namespace: "{{ app_namespace }}"\n        kubeconfig: "{{ kubeconfig_path }}"\n        create_namespace: false\n        values_files:\n          - /home/ubuntu/{{ app_name }}/helm_charts/values.yaml\n        values:\n          ecrImageFull: "{{ aws_account_id }}.dkr.ecr.us-west-2.amazonaws.com/{{ app_name }}:{{ image_tag }}"\n        force: true\n        atomic: false\n'})}),"\n",(0,s.jsx)(n.h3,{id:"step-7---configure-aws-profile",children:"Step 7 - Configure AWS Profile"}),"\n",(0,s.jsxs)(n.p,{children:["Open or create file ",(0,s.jsx)(n.code,{children:"~/.aws/credentials"})," and add (if not already there):"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ini",children:"[myaws]\naws_access_key_id = <your_access_key>\naws_secret_access_key = <your_secret_key>\n"})}),"\n",(0,s.jsx)(n.p,{children:"Then use"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ini",children:"aws configure\n"})}),"\n",(0,s.jsx)(n.p,{children:"And configure your AWS credentials"}),"\n",(0,s.jsx)(n.h3,{id:"step-8---run-deployment",children:"Step 8 - Run deployment"}),"\n",(0,s.jsxs)(n.p,{children:["All deployment-related actions are automated, so no additional actions are required. To deploy the application, you only need to enter a few commands listed below and wait a few minutes. After that, you will be able to connect to the web application using the link you will receive in ",(0,s.jsx)(n.code,{children:"terraform_output"}),". Next, if you wish, you can add GitHub Actions. To do this, follow the instructions in ",(0,s.jsx)(n.a,{href:"https://adminforth.dev/blog/compose-aws-ec2-ecr-terraform-github-actions/#chellenges-when-you-build-on-ci",children:"our other post"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"In ../deploy/terraform folder"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"terraform init\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"terraform apply -auto-approve\n"})}),"\n",(0,s.jsx)(n.h3,{id:"all-done",children:"All done!"}),"\n",(0,s.jsx)(n.p,{children:"Your application is now deployed on Amazon EC2 and available on the Internet."})]})}function p(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},28453:(e,n,a)=>{a.d(n,{R:()=>r,x:()=>l});var s=a(96540);const t={},i=s.createContext(t);function r(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);