"use strict";(self.webpackChunkadminforth=self.webpackChunkadminforth||[]).push([[7544],{176:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>u,frontMatter:()=>i,metadata:()=>s,toc:()=>l});var s=t(450),r=t(4848),o=t(8453);const i={slug:"compose-ec2-deployment-github-actions-registry",title:"Amazon EC2 Deployments with GitHub Actions, Terraform, Docker & Self-hosted Registry",authors:"ivanb",tags:["aws","terraform","github-actions"],description:"The ultimate step-by-step guide to cost-effective, build-time-efficient, and easy managable EC2 deployments using GitHub Actions, Terraform, Docker, and a self-hosted registry.",image:"/ogs/ga-tf-aws.jpg"},a=void 0,c={authorsImageUrls:[void 0]},l=[{value:"Costs for Amazon ECR vs consts for self-hosted registry on EC2",id:"costs-for-amazon-ecr-vs-consts-for-self-hosted-registry-on-ec2",level:2},{value:"Step 1 - Dockerfile and .dockerignore",id:"step-1---dockerfile-and-dockerignore",level:2},{value:"Step 2 - compose.yml",id:"step-2---composeyml",level:2},{value:"Step 3 - create a SSH keypair",id:"step-3---create-a-ssh-keypair",level:2},{value:"Step 4 - create TLS certificates to encrypt traffic between CI and registry",id:"step-4---create-tls-certificates-to-encrypt-traffic-between-ci-and-registry",level:2},{value:"Step 5 - .gitignore file",id:"step-5---gitignore-file",level:2},{value:"Step 6 - file with secrets for local deploy",id:"step-6---file-with-secrets-for-local-deploy",level:2},{value:"Step 7 - main terraform file main.tf",id:"step-7---main-terraform-file-maintf",level:2},{value:"Step 7.1 - Configure AWS Profile",id:"step-71---configure-aws-profile",level:3},{value:"Step 7.2 - Run deployment",id:"step-72---run-deployment",level:3},{value:"Step 8 - Migrate state to the cloud",id:"step-8---migrate-state-to-the-cloud",level:2},{value:"Step 9 - CI/CD - Github Actions",id:"step-9---cicd---github-actions",level:2},{value:"Step 8.1 - Add secrets to GitHub",id:"step-81---add-secrets-to-github",level:3},{value:"Adding secrets",id:"adding-secrets",level:3},{value:"Want to run builds from your local machine?",id:"want-to-run-builds-from-your-local-machine",level:3},{value:"1. You need to make local Docker buildx builder to trust self-signed TLS certificate",id:"1-you-need-to-make-local-docker-buildx-builder-to-trust-self-signed-tls-certificate",level:4},{value:"2. You need to deliver same secrets from local machine as from CI vault",id:"2-you-need-to-deliver-same-secrets-from-local-machine-as-from-ci-vault",level:4},{value:"2. You need to add app.server.local to your hosts file (Windows/WSL only)",id:"2-you-need-to-add-appserverlocal-to-your-hosts-file-windowswsl-only",level:4},{value:"3. Using local build from multiple projects",id:"3-using-local-build-from-multiple-projects",level:4}];function d(e){const n={a:"a",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",img:"img",li:"li",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"alt text",src:t(2508).A+"",width:"1200",height:"630"})}),"\n",(0,r.jsxs)(n.p,{children:["This guide is a hackers extended addition of ",(0,r.jsx)(n.a,{href:"/blog/compose-aws-ec2-ecr-terraform-github-actions/",children:"Deploying AdminForth to EC2 with Amazon ECR"}),". The key difference in this post that we will not use Amazon ECR but self-host registry on EC2 itself. Automatically from terraform. And will see whether we will win something in terms of build time."]}),"\n",(0,r.jsx)(n.h2,{id:"costs-for-amazon-ecr-vs-consts-for-self-hosted-registry-on-ec2",children:"Costs for Amazon ECR vs consts for self-hosted registry on EC2"}),"\n",(0,r.jsx)(n.p,{children:"Most of AWS services are formed from EC2 prices plus some extra overhead for own cost. In same way, Amazon ECR pricing is pretty same."}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Feature"}),(0,r.jsx)(n.th,{children:"Amazon ECR"}),(0,r.jsx)(n.th,{children:"Self-hosted registry on EC2"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Storage"}),(0,r.jsx)(n.td,{children:"$0.10 per GB/month"}),(0,r.jsx)(n.td,{children:"$0.10 per GB/month for gp2 EBS volume"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Data transfer for egress"}),(0,r.jsx)(n.td,{children:"$0.09 per GB"}),(0,r.jsx)(n.td,{children:"$0.09 per GB"})]})]})]}),"\n",(0,r.jsx)(n.p,{children:"So as you can see there is still no difference in terms of cost. However the approach in this system allows to replace Amazon EC2 with any other cloud provider which does not charge for egress traffic."}),"\n",(0,r.jsx)(n.h1,{id:"bechnmarking-build-time",children:"Bechnmarking build time"}),"\n",(0,r.jsxs)(n.p,{children:["When I implmented this solution, I was curious whether it will be faster to build images on EC2 or on CI. So I did a little bit of testing.\nFirst I used results form ",(0,r.jsx)(n.a,{href:"/blog/compose-ec2-deployment-github-actions/",children:"deploying AdminForth to EC2 with Terraform without registry"})," where we built images on EC2. Then I did the same test but with self-hosted registry on EC2 and compared to ",(0,r.jsx)(n.a,{href:"/blog/compose-aws-ec2-ecr-terraform-github-actions/",children:"deploying AdminForth to EC2 with Amazon ECR"})," where we built images on CI and pushed to Amazon ECR."]}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Feature"}),(0,r.jsx)(n.th,{children:"Without Registry (build directly on EC2)"}),(0,r.jsx)(n.th,{children:"With self-hosted registry"}),(0,r.jsx)(n.th,{children:"With Amazon ECR"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Initial build time*"}),(0,r.jsx)(n.td,{children:"3m 13.541s"}),(0,r.jsx)(n.td,{children:"2m 48.412s"}),(0,r.jsx)(n.td,{children:"3m 54s"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsxs)(n.td,{children:["Rebuild time (changed ",(0,r.jsx)(n.code,{children:"index.ts"}),")*"]}),(0,r.jsx)(n.td,{children:"0m 51.653s"}),(0,r.jsx)(n.td,{children:"0m42.131s"}),(0,r.jsx)(n.td,{children:"0m 54.120s"})]})]})]}),"\n",(0,r.jsx)("sub",{children:"* All tests done from local machine (Intel(R) Core(TM) Ultra 9 185H, Docker Desktop/WSL2 64 GB RAM, 300Mbps up/down) up to working state"}),"\n",(0,r.jsx)(n.p,{children:"So it indeed own self-hosted registry is faster then ECR and overall build time of pure AdminForth is faster then building on EC2. When ECR is slower then self-hosted registry, it is because of network speed."}),"\n",(0,r.jsx)(n.h1,{id:"chellenges-when-you-build-on-ci",children:"Chellenges when you build on CI"}),"\n",(0,r.jsx)(n.h1,{id:"registry-authorization-and-traffic-encryption",children:"Registry authorization and traffic encryption"}),"\n",(0,r.jsx)(n.p,{children:"Hosting custom CNCF registry, from other hand is a security responsibility."}),"\n",(0,r.jsx)(n.p,{children:"If you don't protect it right, someone will be able to push any image to your registry and then pull it to your EC2 instance. This is a big security issue, so we have to protect our registry."}),"\n",(0,r.jsx)(n.p,{children:"First of all we need to set some authorization to our registry so everyone who will push/pull images will be authorized. Here we have 2 options: HTTP basic auth and Client certificate auth. We will use first one as it is easier to setup. We will generate basic login and password automatically in terraform so no extra actions are needed from you."}),"\n",(0,r.jsx)(n.p,{children:"But this is not enough. Basic auth is not encrypted, so someone can perform MITM attack and get your credentials. So we need to encrypt traffic between CI and registry. We can do it by using TLS certificates. So we will generate self-signed TLS certificates, and attach them to our registry."}),"\n",(0,r.jsx)(n.p,{children:"Though the challenge is that we need to provide CA certificate to every daemon which will work with our registry. So we need to provide CA certificate to buildx daemon on CI, also if we want to do it from local machine, we need to provide CA certificate to local docker daemon."}),"\n",(0,r.jsx)(n.h1,{id:"practice---deploy-setup",children:"Practice - deploy setup"}),"\n",(0,r.jsxs)(n.p,{children:["Assume you have your AdminForth project in ",(0,r.jsx)(n.code,{children:"myadmin"}),"."]}),"\n",(0,r.jsx)(n.h2,{id:"step-1---dockerfile-and-dockerignore",children:"Step 1 - Dockerfile and .dockerignore"}),"\n",(0,r.jsxs)(n.p,{children:["This guide assumes you have created your AdminForth application with latest version of ",(0,r.jsx)(n.code,{children:"adminforth create-app"})," command.\nThis command already creates a ",(0,r.jsx)(n.code,{children:"Dockerfile"})," and ",(0,r.jsx)(n.code,{children:".dockerignore"})," for you, so you can use them as is."]}),"\n",(0,r.jsx)(n.h2,{id:"step-2---composeyml",children:"Step 2 - compose.yml"}),"\n",(0,r.jsxs)(n.p,{children:["create folder ",(0,r.jsx)(n.code,{children:"deploy"})," and create file ",(0,r.jsx)(n.code,{children:"compose.yml"})," inside:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yml",metastring:'title="deploy/compose.yml"',children:'services:\n  traefik:\n    image: "traefik:v2.5"\n    command:\n      - "--api.insecure=true"\n      - "--providers.docker=true"\n      - "--entrypoints.web.address=:80"\n    ports:\n      - "80:80"\n    volumes:\n      - "/var/run/docker.sock:/var/run/docker.sock:ro"\n\n  myadmin:\n    image: localhost:5000/myadmin:latest\n    build:\n      context: ../adminforth-app\n      tags:\n        - localhost:5000/myadmin:latest\n      cache_from:\n        - type=registry,ref=localhost:5000/myadmin:cache\n      cache_to:\n        - type=registry,ref=localhost:5000/myadmin:cache,mode=max,compression=zstd,image-manifest=true,oci-mediatypes=true\n      \n    pull_policy: always\n    restart: always\n    env_file:\n      - .env.secrets.prod\n\n    volumes:\n      - myadmin-db:/code/db\n    labels:\n      - "traefik.enable=true"\n      - "traefik.http.routers.myadmin.rule=PathPrefix(`/`)"\n      - "traefik.http.services.myadmin.loadbalancer.server.port=3500"\n      - "traefik.http.routers.myadmin.priority=2"\n\nvolumes:\n  myadmin-db:\n'})}),"\n",(0,r.jsx)(n.h2,{id:"step-3---create-a-ssh-keypair",children:"Step 3 - create a SSH keypair"}),"\n",(0,r.jsxs)(n.p,{children:["Make sure you are still in ",(0,r.jsx)(n.code,{children:"deploy"})," folder, run next command:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",metastring:'title="deploy"',children:'mkdir .keys && ssh-keygen -f .keys/id_rsa -N ""\n'})}),"\n",(0,r.jsxs)(n.p,{children:["Now it should create ",(0,r.jsx)(n.code,{children:"deploy/.keys/id_rsa"})," and ",(0,r.jsx)(n.code,{children:"deploy/.keys/id_rsa.pub"})," files with your SSH keypair. Terraform script will put the public key to the EC2 instance and will use private key to connect to the instance. Also you will be able to use it to connect to the instance manually."]}),"\n",(0,r.jsx)(n.h2,{id:"step-4---create-tls-certificates-to-encrypt-traffic-between-ci-and-registry",children:"Step 4 - create TLS certificates to encrypt traffic between CI and registry"}),"\n",(0,r.jsxs)(n.p,{children:["Make sure you are still in ",(0,r.jsx)(n.code,{children:"deploy"})," folder, run next command:"]}),"\n",(0,r.jsx)(n.p,{children:"Run next command to create TLS certificates:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:'openssl req -new -x509 -days 3650 -newkey rsa:4096 -nodes -keyout .keys/ca.key -subj "/CN=My Custom CA" -out .keys/ca.pem\n'})}),"\n",(0,r.jsxs)(n.p,{children:["This will create ",(0,r.jsx)(n.code,{children:"deploy/.keys/ca.key"})," and ",(0,r.jsx)(n.code,{children:"deploy/.keys/ca.pem"})," files."]}),"\n",(0,r.jsx)(n.h2,{id:"step-5---gitignore-file",children:"Step 5 - .gitignore file"}),"\n",(0,r.jsxs)(n.p,{children:["Create ",(0,r.jsx)(n.code,{children:"deploy/.gitignore"})," file with next content:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:".terraform/\n.keys/\n*.tfstate\n*.tfstate.*\n*.tfvars\ntfplan\n.env.secrets.prod\n"})}),"\n",(0,r.jsx)(n.h2,{id:"step-6---file-with-secrets-for-local-deploy",children:"Step 6 - file with secrets for local deploy"}),"\n",(0,r.jsxs)(n.p,{children:["Create file ",(0,r.jsx)(n.code,{children:"deploy/.env.secrets.prod"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"ADMINFORTH_SECRET=<your_secret>\n"})}),"\n",(0,r.jsx)(n.h2,{id:"step-7---main-terraform-file-maintf",children:"Step 7 - main terraform file main.tf"}),"\n",(0,r.jsxs)(n.p,{children:["First of all install Terraform as described here ",(0,r.jsx)(n.a,{href:"https://developer.hashicorp.com/terraform/install#linux",children:"terraform installation"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["Create file ",(0,r.jsx)(n.code,{children:"main.tf"})," in ",(0,r.jsx)(n.code,{children:"deploy"})," folder:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-hcl",metastring:'title="deploy/main.tf"',children:'\nlocals {\n  app_name = "<your_app_name>"\n  aws_region = "us-east-1"\n}\n\nprovider "aws" {\n  region = local.aws_region\n  profile = "myaws"\n}\n\ndata "aws_ami" "ubuntu_linux" {\n  most_recent = true\n  owners      = ["amazon"]\n\n  filter {\n    name   = "name"\n    values = ["ubuntu/images/hvm-ssd-gp3/ubuntu-noble-24.04-amd64-server-*"]\n  }\n}\n\ndata "aws_vpc" "default" {\n  default = true\n}\n\nresource "aws_eip" "eip" {\n domain = "vpc"\n}\nresource "aws_eip_association" "eip_assoc" {\n instance_id   = aws_instance.app_instance.id\n allocation_id = aws_eip.eip.id\n}\n\ndata "aws_subnet" "default_subnet" {\n  filter {\n    name   = "vpc-id"\n    values = [data.aws_vpc.default.id]\n  }\n\n  filter {\n    name   = "default-for-az"\n    values = ["true"]\n  }\n\n  filter {\n    name   = "availability-zone"\n    values = ["${local.aws_region}a"]\n  }\n}\n\nresource "aws_security_group" "instance_sg" {\n  name   = "${local.app_name}-instance-sg"\n  vpc_id = data.aws_vpc.default.id\n\n  ingress {\n    description = "Allow HTTP"\n    from_port   = 80\n    to_port     = 80\n    protocol    = "tcp"\n    cidr_blocks = ["0.0.0.0/0"]\n  }\n\n  ingress {\n    description = "Allow Docker registry"\n    from_port   = 5000\n    to_port     = 5000\n    protocol    = "tcp"\n    cidr_blocks = ["0.0.0.0/0"]\n  }\n\n  # SSH\n  ingress {\n    description = "Allow SSH"\n    from_port   = 22\n    to_port     = 22\n    protocol    = "tcp"\n    cidr_blocks = ["0.0.0.0/0"]\n  }\n\n  egress {\n    description = "Allow all outbound traffic"\n    from_port   = 0\n    to_port     = 0\n    protocol    = "-1"\n    cidr_blocks = ["0.0.0.0/0"]\n  }\n}\n\nresource "aws_key_pair" "app_deployer" {\n  key_name   = "terraform-deploy_${local.app_name}-key"\n  public_key = file("./.keys/id_rsa.pub") # Path to your public SSH key\n}\n\nresource "aws_instance" "app_instance" {\n  ami                    = data.aws_ami.ubuntu_linux.id\n  instance_type          = "t3a.small"  # just change it to another type if you need, check https://instances.vantage.sh/\n  subnet_id              = data.aws_subnet.default_subnet.id\n  vpc_security_group_ids = [aws_security_group.instance_sg.id]\n  key_name               = aws_key_pair.app_deployer.key_name\n\n  # prevent accidental termination of ec2 instance and data loss\n  # if you will need to recreate the instance still (not sure why it can be?), you will need to remove this block manually by next command:\n  # > terraform taint aws_instance.app_instance\n  lifecycle {\n    prevent_destroy = true\n    ignore_changes = [ami]\n  }\n\n  root_block_device {\n    volume_size = 20 // Size in GB for root partition\n    volume_type = "gp2"\n    \n    # Even if the instance is terminated, the volume will not be deleted, delete it manually if needed\n    delete_on_termination = false\n  }\n\n  user_data = <<-EOF\n    #!/bin/bash\n    sudo apt-get update\n    sudo apt-get install ca-certificates curl\n    sudo install -m 0755 -d /etc/apt/keyrings\n    sudo curl -fsSL https://download.docker.com/linux/ubuntu/gpg -o /etc/apt/keyrings/docker.asc\n    sudo chmod a+r /etc/apt/keyrings/docker.asc\n\n    # Add the repository to Apt sources:\n    echo \\\n      "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/ubuntu \\\n      $(. /etc/os-release && echo "$VERSION_CODENAME") stable" | \\\n      sudo tee /etc/apt/sources.list.d/docker.list > /dev/null\n    sudo apt-get update\n\n    sudo apt-get install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin screen\n\n    systemctl start docker\n    systemctl enable docker\n    usermod -a -G docker ubuntu\n\n    echo "done" > /home/ubuntu/user_data_done\n\n  EOF\n\n  tags = {\n    Name = "${local.app_name}-instance"\n  }\n}\n\nresource "null_resource" "wait_for_user_data" {\n  provisioner "remote-exec" {\n    inline = [\n      "echo \'Waiting for EC2 software install to finish...\'",\n      "while [ ! -f /home/ubuntu/user_data_done ]; do echo \'...\'; sleep 2; done",\n      "echo \'EC2 software install finished.\'"\n    ]\n\n    connection {\n      type        = "ssh"\n      user        = "ubuntu"\n      private_key = file("./.keys/id_rsa")\n      host        = aws_eip_association.eip_assoc.public_ip\n    }\n  }\n\n  depends_on = [aws_instance.app_instance]\n}\n\nresource "null_resource" "setup_registry" {\n  provisioner "local-exec" {\n    command = <<-EOF\n      echo "Generating secret for local registry"\n      sha256sum ./.keys/id_rsa | cut -d \' \' -f1 | tr -d \'\\n\' > ./.keys/registry.pure\n\n      echo "Creating htpasswd file for local registry"\n      docker run --rm --entrypoint htpasswd httpd:2 -Bbn ci-user $(cat ./.keys/registry.pure) > ./.keys/registry.htpasswd\n\n      echo "Generating server certificate for registry"\n      openssl genrsa -out ./.keys/registry.key 4096\n      echo "subjectAltName=DNS:appserver.local,DNS:localhost,IP:127.0.0.1" > san.ext\n      openssl req -new -key ./.keys/registry.key -subj "/CN=appserver.local" -addext "$(cat san.ext)" -out ./.keys/registry.csr\n\n      openssl x509 -req -days 365 -CA ./.keys/ca.pem -CAkey ./.keys/ca.key -set_serial 01 -in ./.keys/registry.csr -extfile san.ext -out ./.keys/registry.crt \n\n      echo "Copying registry secret files to the instance"\n      rsync -t -avz -e "ssh -i ./.keys/id_rsa -o StrictHostKeyChecking=no" \\\n        ./.keys/registry.* ubuntu@${aws_eip_association.eip_assoc.public_ip}:/home/ubuntu/registry-auth\n    EOF\n  }\n\n  provisioner "remote-exec" {\n    inline = [<<-EOF\n      # remove old registry if exists\n      docker rm -f registry\n      # run new registry\n      docker run -d --network host \\\n        --name registry \\\n        --restart always \\\n        -v /home/ubuntu/registry-data:/var/lib/registry \\\n        -v /home/ubuntu/registry-auth:/auth\\\n        -e "REGISTRY_AUTH=htpasswd" \\\n        -e "REGISTRY_AUTH_HTPASSWD_REALM=Registry Realm" \\\n        -e "REGISTRY_AUTH_HTPASSWD_PATH=/auth/registry.htpasswd" \\\n        -e "REGISTRY_HTTP_TLS_CERTIFICATE=/auth/registry.crt" \\\n        -e "REGISTRY_HTTP_TLS_KEY=/auth/registry.key" \\\n        registry:2\n\n      EOF\n    ]\n\n    connection {\n      type        = "ssh"\n      user        = "ubuntu"\n      private_key = file("./.keys/id_rsa")\n      host        = aws_eip_association.eip_assoc.public_ip\n    }\n  }\n\n  triggers = {\n    always_run = 1 # change number to redeploy registry (if for some reason it was removed)\n  }\n\n  depends_on = [null_resource.wait_for_user_data]\n}\n\n\nresource "null_resource" "sync_files_and_run" {\n\n  provisioner "local-exec" {\n    command = <<-EOF\n\n      # map appserver.local to the instance (in CI we don\'t know the IP, so have to use this mapping)\n      # so then in GA pipeline we will use \n      #  - name: Set up Docker Buildx\n      #   uses: docker/setup-buildx-action@v3\n      #   with:\n      #     buildkitd-config-inline: |\n      #       [registry."appserver.local:5000"]\n      #         ca=["deploy/.keys/ca.pem"]\n\n      grep -q "appserver.local" /etc/hosts || echo "${aws_eip_association.eip_assoc.public_ip} appserver.local" | sudo tee -a /etc/hosts\n\n      # hosts modification may take some time to apply\n      sleep 5\n\n      # generate buildx authorization\n      sha256sum ./.keys/id_rsa | cut -d \' \' -f1 | tr -d \'\\n\' > ./.keys/registry.pure\n      echo \'{"auths":{"appserver.local:5000":{"auth":"\'$(echo -n "ci-user:$(cat ./.keys/registry.pure)" | base64 -w 0)\'"}}}\' > ~/.docker/config.json\n\n      echo "Running build"\n      docker buildx bake --progress=plain --push --allow=fs.read=.. -f compose.yml\n\n      # compose temporarily it is not working https://github.com/docker/compose/issues/11072#issuecomment-1848974315\n      # docker compose --progress=plain -p app -f ./compose.yml build --push\n\n      # if you will change host, pleasee add -o StrictHostKeyChecking=no\n      echo "Copy files to the instance" \n      rsync -t -avz --mkpath -e "ssh -i ./.keys/id_rsa -o StrictHostKeyChecking=no" \\\n        --delete \\\n        --exclude \'.terraform\' \\\n        --exclude \'.keys\' \\\n        --exclude \'tfplan\' \\\n        . ubuntu@${aws_eip_association.eip_assoc.public_ip}:/home/ubuntu/app/deploy/\n\n      EOF\n  }\n\n  # Run docker compose after files have been copied\n  provisioner "remote-exec" {\n    inline = [<<-EOF\n      # login to docker registry\n      cat /home/ubuntu/registry-auth/registry.pure | docker login localhost:5000 -u ci-user --password-stdin\n        \n      cd /home/ubuntu/app/deploy\n\n      echo "Spinning up the app"\n      docker compose --progress=plain -p app -f compose.yml up -d --remove-orphans\n\n      # cleanup unused cache (run in background to not block terraform)\n      screen -dm docker system prune -f\n      screen -dm docker exec registry registry garbage-collect /etc/docker/registry/config.yml --delete-untagged=true \n    EOF\n    ]\n\n    connection {\n      type        = "ssh"\n      user        = "ubuntu"\n      private_key = file("./.keys/id_rsa")\n      host        = aws_eip_association.eip_assoc.public_ip\n    }\n\n\n  }\n\n  # Ensure the resource is triggered every time based on timestamp or file hash\n  triggers = {\n    always_run = timestamp()\n  }\n\n  depends_on = [aws_eip_association.eip_assoc, null_resource.setup_registry]\n}\n\n\noutput "instance_public_ip" {\n  value = aws_eip_association.eip_assoc.public_ip\n}\n\n\n######### META, tf state ##############\n\n\n# S3 bucket for storing Terraform state\nresource "aws_s3_bucket" "terraform_state" {\n  bucket = "${local.app_name}-terraform-state"\n}\n\nresource "aws_s3_bucket_lifecycle_configuration" "terraform_state" {\n  bucket = aws_s3_bucket.terraform_state.bucket\n\n  rule {\n    status = "Enabled"\n    id = "Keep only the latest version of the state file"\n\n    filter {\n      prefix = ""\n    }\n\n    noncurrent_version_expiration {\n      noncurrent_days = 30\n    }\n  }\n}\n\nresource "aws_s3_bucket_versioning" "terraform_state" {\n  bucket = aws_s3_bucket.terraform_state.bucket\n\n  versioning_configuration {\n    status = "Enabled"\n  }\n}\n\nresource "aws_s3_bucket_server_side_encryption_configuration" "terraform_state" {\n  bucket = aws_s3_bucket.terraform_state.bucket\n\n  rule {\n    apply_server_side_encryption_by_default {\n      sse_algorithm     = "AES256"\n    }\n  }\n}\n\n\n\n'})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.p,{children:["\ud83d\udc46 Replace ",(0,r.jsx)(n.code,{children:"<your_app_name>"})," with your app name (no spaces, only underscores or letters)"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"step-71---configure-aws-profile",children:"Step 7.1 - Configure AWS Profile"}),"\n",(0,r.jsxs)(n.p,{children:["Open or create file ",(0,r.jsx)(n.code,{children:"~/.aws/credentials"})," and add (if not already there):"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ini",children:"[myaws]\naws_access_key_id = <your_access_key>\naws_secret_access_key = <your_secret_key>\n"})}),"\n",(0,r.jsx)(n.h3,{id:"step-72---run-deployment",children:"Step 7.2 - Run deployment"}),"\n",(0,r.jsx)(n.p,{children:"We will run first deployment from local machine to create S3 bucket for storing Terraform state. In other words this deployment will create resources needed for storing Terraform state in the cloud and runnign deployment from GitHub actions."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"terraform init\n"})}),"\n",(0,r.jsx)(n.p,{children:"Now run deployement:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"terraform apply -auto-approve\n"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.p,{children:["\ud83d\udc46 Please note that this command might block ask you your ",(0,r.jsx)(n.code,{children:"sudo"})," password to append ",(0,r.jsx)(n.code,{children:"appserver.local"})," to ",(0,r.jsx)(n.code,{children:"/etc/hosts"})," file."]}),"\n"]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"\ud83d\udc46 Please note that command might show errors about pushing images, this is fine because current deployment is done here only to setup S3 bucket for state migration before migrating to cloud."}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"step-8---migrate-state-to-the-cloud",children:"Step 8 - Migrate state to the cloud"}),"\n",(0,r.jsx)(n.p,{children:"First deployment had to create S3 bucket for storing Terraform state. Now we need to migrate the state to the cloud."}),"\n",(0,r.jsxs)(n.p,{children:["Add to the end of ",(0,r.jsx)(n.code,{children:"main.tf"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-hcl",metastring:'title="main.tf"',children:'\n# Configure the backend to use the S3 bucket\nterraform {\n backend "s3" {\n   bucket         = "<your_app_name>-terraform-state"\n   key            = "state.tfstate"  # Define a specific path for the state file\n   region         = "us-east-1"\n   profile        = "myaws"\n   use_lockfile   = true\n }\n}\n'})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.p,{children:["\ud83d\udc46 Replace ",(0,r.jsx)(n.code,{children:"<your_app_name>"})," with your app name (no spaces, only underscores or letters).\nUnfortunately we can't use variables, HashiCorp thinks it is too dangerous \ud83d\ude25"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Now run:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"terraform init -migrate-state\n"})}),"\n",(0,r.jsx)(n.p,{children:"Now run test deployment:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"terraform apply -auto-approve\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Now you can delete local ",(0,r.jsx)(n.code,{children:"terraform.tfstate"})," file and ",(0,r.jsx)(n.code,{children:"terraform.tfstate.backup"})," file as they are in the cloud now."]}),"\n",(0,r.jsx)(n.h2,{id:"step-9---cicd---github-actions",children:"Step 9 - CI/CD - Github Actions"}),"\n",(0,r.jsxs)(n.p,{children:["Create file ",(0,r.jsx)(n.code,{children:".github/workflows/deploy.yml"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yml",metastring:'title=".github/workflows/deploy.yml"',children:'name: Deploy myadmin\nrun-name: ${{ github.actor }} builds myadmin \ud83d\ude80\non: [push]\njobs:\n  Explore-GitHub-Actions:\n    runs-on: ubuntu-latest\n\n    concurrency:\n      group: build-group\n      cancel-in-progress: false\n\n    steps:\n      - run: echo "\ud83c\udf89 The job was automatically triggered by a ${{ github.event_name }} event."\n      - run: echo "\ud83d\udc27 This job is now running on a ${{ runner.os }} server"\n      - run: echo "\ud83d\udd0e The name of your branch is ${{ github.ref }}"\n      - name: Check out repository code\n        uses: actions/checkout@v4\n\n      - name: Set up Terraform\n        uses: hashicorp/setup-terraform@v2\n        with:\n          terraform_version: 1.10.1 \n      \n      - name: Import Registry CA\n        run: |\n          mkdir -p deploy/.keys\n          echo "$VAULT_REGISTRY_CA_PEM" > deploy/.keys/ca.pem\n          echo "$VAULT_REGISTRY_CA_KEY" > deploy/.keys/ca.key\n        env:\n          VAULT_REGISTRY_CA_PEM: ${{ secrets.VAULT_REGISTRY_CA_PEM }}\n          VAULT_REGISTRY_CA_KEY: ${{ secrets.VAULT_REGISTRY_CA_KEY }}\n\n\n      - name: Set up Docker Buildx\n        uses: docker/setup-buildx-action@v3\n        with:\n          buildkitd-config-inline: |\n            [registry."appserver.local:5000"]\n              ca=["deploy/.keys/ca.pem"]\n              \n          # use host network for resolving appserver.local\n          driver-opts: network=host\n\n      - name: Import registry SSH keys\n        run: |\n          mkdir -p deploy/.keys\n          echo "$VAULT_SSH_PRIVATE_KEY" > deploy/.keys/id_rsa\n          echo "$VAULT_SSH_PUBLIC_KEY" > deploy/.keys/id_rsa.pub\n          chmod 600 deploy/.keys/id_rsa*\n        env:\n          VAULT_SSH_PRIVATE_KEY: ${{ secrets.VAULT_SSH_PRIVATE_KEY }}\n          VAULT_SSH_PUBLIC_KEY: ${{ secrets.VAULT_SSH_PUBLIC_KEY }}\n\n      - name: Setup AWS credentials\n        run: |\n          mkdir -p ~/.aws\n          cat <<EOL > ~/.aws/credentials\n          [myaws]\n          aws_access_key_id=${VAULT_AWS_ACCESS_KEY_ID}\n          aws_secret_access_key=${VAULT_AWS_SECRET_ACCESS_KEY}\n          EOL\n        env:\n          VAULT_AWS_ACCESS_KEY_ID: ${{ secrets.VAULT_AWS_ACCESS_KEY_ID }}\n          VAULT_AWS_SECRET_ACCESS_KEY: ${{ secrets.VAULT_AWS_SECRET_ACCESS_KEY }}\n\n      - name: Prepare env\n        run: |\n          echo "ADMINFORTH_SECRET=$VAULT_ADMINFORTH_SECRET" > deploy/.env.secrets.prod\n        env:\n          VAULT_ADMINFORTH_SECRET: ${{ secrets.VAULT_ADMINFORTH_SECRET }}\n\n      - name: Terraform build\n        run: |\n          cd deploy\n          terraform init -reconfigure\n          # example of unlocking tf state if needed\n          # terraform force-unlock fb397548-8697-ea93-ab80-128a4f508fdf --force\n          terraform plan -out=tfplan \n          terraform apply tfplan \n                \n          \n      - run: echo "\ud83c\udf4f This job\'s status is ${{ job.status }}."\n'})}),"\n",(0,r.jsx)(n.h3,{id:"step-81---add-secrets-to-github",children:"Step 8.1 - Add secrets to GitHub"}),"\n",(0,r.jsxs)(n.p,{children:["Go to your GitHub repository, then ",(0,r.jsx)(n.code,{children:"Settings"})," -> ",(0,r.jsx)(n.code,{children:"Secrets"})," -> ",(0,r.jsx)(n.code,{children:"New repository secret"})," and add:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"VAULT_AWS_ACCESS_KEY_ID"})," - your AWS access key"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"VAULT_AWS_SECRET_ACCESS_KEY"})," - your AWS secret key"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"VAULT_SSH_PRIVATE_KEY"})," - execute ",(0,r.jsx)(n.code,{children:"cat ~/.ssh/id_rsa"})," and paste to GitHub secrets"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"VAULT_SSH_PUBLIC_KEY"})," - execute ",(0,r.jsx)(n.code,{children:"cat ~/.ssh/id_rsa.pub"})," and paste to GitHub secrets"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"VAULT_REGISTRY_CA_PEM"})," - execute ",(0,r.jsx)(n.code,{children:"cat deploy/.keys/ca.pem"})," and paste to GitHub secrets"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"VAULT_REGISTRY_CA_KEY"})," - execute ",(0,r.jsx)(n.code,{children:"cat deploy/.keys/ca.key"})," and paste to GitHub secrets"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"VAULT_ADMINFORTH_SECRET"})," - generate some random string and paste to GitHub secrets, e.g. ",(0,r.jsx)(n.code,{children:"openssl rand -base64 32 | tr -d '\\n'"})]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Now you can push your changes to GitHub and see how it will be deployed automatically."}),"\n",(0,r.jsx)(n.h3,{id:"adding-secrets",children:"Adding secrets"}),"\n",(0,r.jsx)(n.p,{children:"Once you will have sensitive tokens/passwords in your apps you have to store them in a secure way."}),"\n",(0,r.jsx)(n.p,{children:"Simplest way is to use GitHub secrets."}),"\n",(0,r.jsxs)(n.p,{children:["Let's imagine you have ",(0,r.jsx)(n.code,{children:"OPENAI_API_KEY"})," which will be used one of AI-powered plugins of adminforth. We can't put this key to the code, so we have to store it in GitHub secrets."]}),"\n",(0,r.jsxs)(n.p,{children:["Open your GitHub repository, then ",(0,r.jsx)(n.code,{children:"Settings"})," -> ",(0,r.jsx)(n.code,{children:"Secrets"})," -> ",(0,r.jsx)(n.code,{children:"New repository secret"})," and add ",(0,r.jsx)(n.code,{children:"VAULT_OPENAI_API_KEY"})," with your key."]}),"\n",(0,r.jsxs)(n.p,{children:["Now open GitHub actions file and add it to the ",(0,r.jsx)(n.code,{children:"env"})," section:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yml",metastring:'title=".github/workflows/deploy.yml"',children:'      - name: Prepare env\n        run: |\n          echo "ADMINFORTH_SECRET=$VAULT_ADMINFORTH_SECRET" > deploy/.env.secrets.prod\n//diff-add\n          echo "OPENAI_API_KEY=$VAULT_OPENAI_API_KEY" >> deploy/.env.secrets.prod\n//diff-add\n        env:\n          VAULT_ADMINFORTH_SECRET: ${{ secrets.VAULT_ADMINFORTH_SECRET }}\n//diff-add\n          VAULT_OPENAI_API_KEY: ${{ secrets.VAULT_OPENAI_API_KEY }}\n'})}),"\n",(0,r.jsx)(n.p,{children:"In the same way you can add any other secrets to your GitHub actions."}),"\n",(0,r.jsx)(n.h3,{id:"want-to-run-builds-from-your-local-machine",children:"Want to run builds from your local machine?"}),"\n",(0,r.jsx)(n.p,{children:"This guide originally was created to run full builds from GitHub actions only, so out of the box it will fail to push images to registry from your local machine."}),"\n",(0,r.jsx)(n.p,{children:"But for debug purporses you can run it from your local machine too with some addition steps."}),"\n",(0,r.jsx)(n.h4,{id:"1-you-need-to-make-local-docker-buildx-builder-to-trust-self-signed-tls-certificate",children:"1. You need to make local Docker buildx builder to trust self-signed TLS certificate"}),"\n",(0,r.jsxs)(n.p,{children:["Create folder ",(0,r.jsx)(n.code,{children:"deploy/.local"})," and create next files:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-toml",metastring:"title=deploy/.local/buildkitd.toml ",children:'[registry."appserver.local:5000"]\n  insecure = false\n  ca = ["../.keys/ca.pem"]\n'})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sh",metastring:"title=deploy/.local/create-builder.sh",children:'#!/bin/bash\ncd "$(dirname "$0")"\ndocker buildx rm mybuilder || true\ndocker buildx create --name mybuilder --driver docker-container   --use --config ./buildkitd.toml\n'})}),"\n",(0,r.jsx)(n.p,{children:"Now create builder:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"bash .local/create-builder.sh\n"})}),"\n",(0,r.jsx)(n.h4,{id:"2-you-need-to-deliver-same-secrets-from-local-machine-as-from-ci-vault",children:"2. You need to deliver same secrets from local machine as from CI vault"}),"\n",(0,r.jsxs)(n.p,{children:["Create file ",(0,r.jsx)(n.code,{children:"deploy/.env.secrets.prod"})," with next content:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sh",children:"ADMINFORTH_SECRET=<your secret>\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Please note that if you are running builds both from GA and local, the ",(0,r.jsx)(n.code,{children:"ADMINFORTH_SECRET"})," should much to GA secret. Otherwise all existing users will be logged out."]}),"\n",(0,r.jsx)(n.h4,{id:"2-you-need-to-add-appserverlocal-to-your-hosts-file-windowswsl-only",children:"2. You need to add app.server.local to your hosts file (Windows/WSL only)"}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.p,{children:["This step is not needed on Linux / Mac because teraform provisioner will autiomatically add it to ",(0,r.jsx)(n.code,{children:"/etc/hosts"})," file.\nHowever in WSL we can't modify Windows native hosts file, so we need to do it manually."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"In power shell run"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'Start-Process notepad "C:\\Windows\\System32\\drivers\\etc\\hosts" -Verb runAs\n'})}),"\n",(0,r.jsx)(n.p,{children:"Check your public IP in Terraform output and add"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"<your public ip> appserver.local\n"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"Bad news is that instance public IP will be known only after first run, so some steps would fail because there will be no hosts mapping. However since EC2 provisioning takes some time it is even possible to copy IP from terminal and inser it to hosts file from first run \ud83e\udd2a"}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"3-using-local-build-from-multiple-projects",children:"3. Using local build from multiple projects"}),"\n",(0,r.jsxs)(n.p,{children:["The easiest way would be probably to rename ",(0,r.jsx)(n.code,{children:"appserver.local"})," to unique name for each project."]}),"\n",(0,r.jsxs)(n.p,{children:["Then you can put all certificate mappings to a ",(0,r.jsx)(n.code,{children:"buildkitd.toml"})," and move it along with ",(0,r.jsx)(n.code,{children:"create-builder.sh"})," script to a common folder, e.g. home"]})]})}function u(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},2508:(e,n,t)=>{t.d(n,{A:()=>s});const s=t.p+"assets/images/ga-tf-aws-fd1b40a236f46c0ffc8c09ef37abaf38.jpg"},8453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>a});var s=t(6540);const r={},o=s.createContext(r);function i(e){const n=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),s.createElement(o.Provider,{value:n},e.children)}},450:e=>{e.exports=JSON.parse('{"permalink":"/blog/compose-ec2-deployment-github-actions-registry","source":"@site/blog/2025-02-19-compose-ec2-deployment-github-actions-registry/index.md","title":"Amazon EC2 Deployments with GitHub Actions, Terraform, Docker & Self-hosted Registry","description":"The ultimate step-by-step guide to cost-effective, build-time-efficient, and easy managable EC2 deployments using GitHub Actions, Terraform, Docker, and a self-hosted registry.","date":"2025-02-19T00:00:00.000Z","tags":[{"inline":false,"label":"AWS","permalink":"/blog/tags/aws","description":"Amazon Web Services (AWS) is a cloud computing platform that provides a wide range of services for building and deploying applications."},{"inline":false,"label":"Terraform","permalink":"/blog/tags/terraform","description":"Terraform is an open-source infrastructure as code software tool created by HashiCorp that enables users to define and provision data center infrastructure using a declarative configuration language."},{"inline":false,"label":"GitHub Actions","permalink":"/blog/tags/github-actions","description":"GitHub Actions is a continuous integration and continuous deployment (CI/CD) service provided by GitHub that allows you to automate your software development workflows."}],"readingTime":15.745,"hasTruncateMarker":true,"authors":[{"name":"Ivan Borshchov","title":"Maintainer of AdminForth","url":"https://github.com/ivictbor","imageURL":"https://avatars.githubusercontent.com/u/1838656?v=4","key":"ivanb","page":null}],"frontMatter":{"slug":"compose-ec2-deployment-github-actions-registry","title":"Amazon EC2 Deployments with GitHub Actions, Terraform, Docker & Self-hosted Registry","authors":"ivanb","tags":["aws","terraform","github-actions"],"description":"The ultimate step-by-step guide to cost-effective, build-time-efficient, and easy managable EC2 deployments using GitHub Actions, Terraform, Docker, and a self-hosted registry.","image":"/ogs/ga-tf-aws.jpg"},"unlisted":false,"prevItem":{"title":"Setup AdminForth Authorization via Keycloak","permalink":"/blog/keycloak-setup-example"},"nextItem":{"title":"IaaC Simplified: Amazon EC2 Deployments with GitHub Actions, Terraform, Docker & Amazon ECR","permalink":"/blog/compose-aws-ec2-ecr-terraform-github-actions"}}')}}]);