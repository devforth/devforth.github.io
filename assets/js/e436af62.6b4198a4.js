"use strict";(self.webpackChunkadminforth=self.webpackChunkadminforth||[]).push([[6302],{13998:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>p,frontMatter:()=>s,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"tutorial/Plugins/05-1-upload-api","title":"Upload API","description":"The Upload plugin exposes an API for both backend-only uploads and direct browser uploads using presigned URLs. You can:","source":"@site/docs/tutorial/08-Plugins/05-1-upload-api.md","sourceDirName":"tutorial/08-Plugins","slug":"/tutorial/Plugins/05-1-upload-api","permalink":"/docs/tutorial/Plugins/05-1-upload-api","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Upload","permalink":"/docs/tutorial/Plugins/05-0-upload"},"next":{"title":"Plugin development guide","permalink":"/docs/tutorial/Advanced/plugin-development"}}');var o=r(74848),i=r(28453);const s={},a="Upload API",d={},l=[{value:"Uploading from backend (Buffer API)",id:"uploading-from-backend-buffer-api",level:2},{value:"uploadFromBufferToNewRecord",id:"uploadfrombuffertonewrecord",level:3},{value:"uploadFromBufferToExistingRecord",id:"uploadfrombuffertoexistingrecord",level:3},{value:"Presigned uploading from the frontend",id:"presigned-uploading-from-the-frontend",level:2},{value:"Getting a presigned upload URL (getUploadUrl)",id:"getting-a-presigned-upload-url-getuploadurl",level:3},{value:"Committing to an existing record (commitUrlToUpdateExistingRecord)",id:"committing-to-an-existing-record-commiturltoupdateexistingrecord",level:3},{value:"Committing and creating a new record (commitUrlToNewRecord)",id:"committing-and-creating-a-new-record-commiturltonewrecord",level:3},{value:"Uploading to one field from another (custom create/edit components)",id:"uploading-to-one-field-from-another-custom-createedit-components",level:2}];function c(e){const n={blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"upload-api",children:"Upload API"})}),"\n",(0,o.jsx)(n.p,{children:"The Upload plugin exposes an API for both backend-only uploads and direct browser uploads using presigned URLs. You can:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["Upload from the backend (Node.js ",(0,o.jsx)(n.code,{children:"Buffer"}),") and either create a new record or update an existing one."]}),"\n",(0,o.jsxs)(n.li,{children:["Generate a presigned upload URL on the backend, send it to the frontend, and upload directly from the browser to your storage provider using an HTTP ",(0,o.jsx)(n.code,{children:"PUT"})," request (raw file as body, plus any ",(0,o.jsx)(n.code,{children:"uploadExtraParams"})," as headers).","\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["After the file is uploaded, it is considered ",(0,o.jsx)(n.strong,{children:"temporary"})," and can be auto-deleted until you commit it."]}),"\n",(0,o.jsxs)(n.li,{children:["You can commit by calling ",(0,o.jsx)(n.code,{children:"commitUrlToNewRecord"})," or ",(0,o.jsx)(n.code,{children:"commitUrlToUpdateExistingRecord"})," from your custom API."]}),"\n",(0,o.jsxs)(n.li,{children:["Or (only for custom create/edit components on the same resource) you can commit by writing ",(0,o.jsx)(n.code,{children:"filePath"})," into the ",(0,o.jsx)(n.code,{children:"pathColumnName"})," field using ",(0,o.jsx)(n.code,{children:"update:recordFieldValue"}),"."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsxs)(n.p,{children:["Note: for presigned browser uploads the upload is performed via an HTTP ",(0,o.jsx)(n.code,{children:"PUT"})," request with the raw file as the request body.\n",(0,o.jsx)(n.code,{children:"uploadExtraParams"})," (if returned) must be sent as ",(0,o.jsx)(n.strong,{children:"HTTP headers"})," during that upload."]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"uploading-from-backend-buffer-api",children:"Uploading from backend (Buffer API)"}),"\n",(0,o.jsx)(n.p,{children:"This API is useful when files are produced entirely on the backend (for example, reports generated by a background job or files received from a webhook), so you don't need to send them through the browser."}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsxs)(n.p,{children:["\u26a0\ufe0f For large files we ",(0,o.jsx)(n.strong,{children:"do not"})," recommend sending the data to your backend and then uploading again from there. Instead, use the presigned upload API from the frontend (see the next section)."]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"uploadfrombuffertonewrecord",children:"uploadFromBufferToNewRecord"}),"\n",(0,o.jsxs)(n.p,{children:["Uploads a file from a Node.js ",(0,o.jsx)(n.code,{children:"Buffer"}),", automatically creates a record in the resource, and returns both the stored file path and a preview URL."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",metastring:'title="./some-backend-service.ts"',children:"import { admin } from './admin'; // your AdminForth instance\n\n...\nplugins: [\n  new UploadPlugin({\n    id: 'my_reports_plugin', // unique identifier for your plugin instance\n    ....\n  })\n]\n...\n\nconst plugin = admin.getPluginById('my_reports_plugin');\n\nconst { path, previewUrl } = await plugin.uploadFromBufferToNewRecord({\n  filename: 'report.pdf',\n  contentType: 'application/pdf',\n  buffer, // Node.js Buffer with file content\n  adminUser, // current admin user or system user\n  // or if you are using non-adminforth handlers, e.g. public API\n  // adminUser: { isExternalUser: true, pk: null, dbUser: {}, username: 'empty' },\n  recordAttributes: {\n    title: 'Generated report',\n    listed: false,\n  },\n});\n"})}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Uses the configured storage adapter (S3, local, etc.) to store the file."}),"\n",(0,o.jsxs)(n.li,{children:["Automatically creates a new record and stores the file path into the column defined by ",(0,o.jsx)(n.code,{children:"pathColumnName"}),", together with any extra ",(0,o.jsx)(n.code,{children:"recordAttributes"})," you pass."]}),"\n",(0,o.jsxs)(n.li,{children:["Returns an object ",(0,o.jsx)(n.code,{children:"{ path, previewUrl }"}),", where ",(0,o.jsx)(n.code,{children:"previewUrl"})," is the same URL used for previews inside AdminForth."]}),"\n"]}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"previewUrl"})," is an absolute URL which you can use in emails / blogs / other places."]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"uploadfrombuffertoexistingrecord",children:"uploadFromBufferToExistingRecord"}),"\n",(0,o.jsxs)(n.p,{children:["If you already have a record and only want to replace the file referenced in its ",(0,o.jsx)(n.code,{children:"pathColumnName"})," field, use ",(0,o.jsx)(n.code,{children:"uploadFromBufferToExistingRecord"}),". It uploads a file from a Node.js ",(0,o.jsx)(n.code,{children:"Buffer"}),", updates the existing record, and returns the new file path and preview URL."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",metastring:'title="./some-backend-service.ts"',children:"const plugin = admin.getPluginById('my_reports_plugin');\n\nconst { path, previewUrl } = await plugin.uploadFromBufferToExistingRecord({\n  recordId: existingRecordId, // primary key of the record to update\n  filename: 'report.pdf',\n  contentType: 'application/pdf',\n  buffer,        // Node.js Buffer with file content\n  adminUser,     // current admin user or system user\n  // or if you are using non-adminforth handlers, e.g. public API\n  // adminUser: { isExternalUser: true, pk: null, dbUser: {}, username: 'empty' },\n  extra: {},     // optional extra meta for your hooks / audit\n});\n"})}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["Uses the same storage adapter and validation rules as ",(0,o.jsx)(n.code,{children:"uploadFromBufferToNewRecord"})," (file extension whitelist, ",(0,o.jsx)(n.code,{children:"maxFileSize"}),", ",(0,o.jsx)(n.code,{children:"filePath"})," callback, etc.)."]}),"\n",(0,o.jsxs)(n.li,{children:["Does ",(0,o.jsx)(n.strong,{children:"not"})," create a new record \u2013 it only updates the existing one identified by ",(0,o.jsx)(n.code,{children:"recordId"}),", replacing the value in ",(0,o.jsx)(n.code,{children:"pathColumnName"})," with the new storage path."]}),"\n",(0,o.jsxs)(n.li,{children:["If the generated ",(0,o.jsx)(n.code,{children:"filePath"})," is the same as the current value in the record, it throws an error to help you avoid CDN/browser caching issues. To force a refresh, make sure your ",(0,o.jsx)(n.code,{children:"filePath"})," callback produces a different key (for example, include a timestamp or random UUID)."]}),"\n"]}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsxs)(n.p,{children:["\u26a0\ufe0f The same recommendation about large files applies here: avoid using ",(0,o.jsx)(n.code,{children:"uploadFromBufferToExistingRecord"})," for very large uploads; prefer a presigned upload flow from the frontend instead."]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"presigned-uploading-from-the-frontend",children:"Presigned uploading from the frontend"}),"\n",(0,o.jsxs)(n.p,{children:["For files that originate in the browser (drag & drop, file input, custom SPA, etc.), the recommended approach is a ",(0,o.jsx)(n.strong,{children:"direct upload"})," from the frontend to your storage provider using a presigned URL. The flow looks like this:"]}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsx)(n.li,{children:"Your custom or admin frontend sends a request to your backend."}),"\n",(0,o.jsxs)(n.li,{children:["The backend calls ",(0,o.jsx)(n.code,{children:"plugin.getUploadUrl(...)"})," and returns ",(0,o.jsx)(n.code,{children:"{ uploadUrl, filePath, uploadExtraParams, pathColumnName }"})," to the frontend."]}),"\n",(0,o.jsxs)(n.li,{children:["The frontend uploads the file directly to ",(0,o.jsx)(n.code,{children:"uploadUrl"})," using ",(0,o.jsx)(n.code,{children:"XMLHttpRequest"})," with method ",(0,o.jsx)(n.code,{children:"PUT"})," (sending the file as the request body and attaching ",(0,o.jsx)(n.code,{children:"uploadExtraParams"})," as request headers). This allows tracking upload progress."]}),"\n",(0,o.jsxs)(n.li,{children:["After the upload completes, you ",(0,o.jsx)(n.strong,{children:"commit"})," the uploaded file to a record using either:","\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"plugin.commitUrlToUpdateExistingRecord"})," (update existing record), or"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"plugin.commitUrlToNewRecord"})," (create new record), or"]}),"\n",(0,o.jsxs)(n.li,{children:["by writing ",(0,o.jsx)(n.code,{children:"filePath"})," into the column named by ",(0,o.jsx)(n.code,{children:"pathColumnName"})," and letting the plugin\u2019s hooks mark the file as permanent. This should be done only from custom edit/create components on same resource as plugin installed."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["By default, files uploaded via ",(0,o.jsx)(n.code,{children:"getUploadUrl"})," are treated as ",(0,o.jsx)(n.strong,{children:"temporary"})," and candidates for auto-deletion. They become permanent only after you commit them or write them to ",(0,o.jsx)(n.code,{children:"pathColumnName"}),"."]}),"\n",(0,o.jsx)(n.h3,{id:"getting-a-presigned-upload-url-getuploadurl",children:"Getting a presigned upload URL (getUploadUrl)"}),"\n",(0,o.jsx)(n.p,{children:"On the backend (Express, same style as other custom APIs):"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",metastring:'title="./index.ts"',children:"import type { IAdminUserExpressRequest } from 'adminforth';\nimport express from 'express';\n\n...\n\napp.post(\n  `${ADMIN_BASE_URL}/api/uploads/get-url-existing`,\n  admin.express.authorize(async (req: IAdminUserExpressRequest, res: express.Response) => {\n    const { recordId, filename, contentType, size } = req.body;\n\n    const plugin = admin.getPluginById('my_reports_plugin');\n\n    const { uploadUrl, filePath, uploadExtraParams, pathColumnName } = await plugin.getUploadUrl({\n      recordId, // can be undefined for new records\n      filename, // e.g. file.name\n      contentType, // e.g. file.type\n      size, // optional, will be validated against maxFileSize to drop error earlier\n    });\n\n    res.json({ uploadUrl, filePath, uploadExtraParams, pathColumnName });\n  }),\n);\n"})}),"\n",(0,o.jsx)(n.p,{children:"On the frontend:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",metastring:'title="./some-frontend.ts"',children:"const file = input.files[0];\n\n// 1) Ask your backend to generate upload URL\nconst { uploadUrl, filePath, uploadExtraParams } = await fetch('/api/uploads/get-url-existing', {\n  method: 'POST',\n  headers: { 'Content-Type': 'application/json' },\n  body: JSON.stringify({\n    recordId,               // omit for new record flow\n    filename: file.name,\n    contentType: file.type,\n    size: file.size,\n  }),\n}).then(r => r.json());\n\n// 2) Direct upload from browser to storage\nawait new Promise<void>((resolve, reject) => {\n  const xhr = new XMLHttpRequest();\n\n  xhr.upload.onprogress = (e) => {\n    if (e.lengthComputable) {\n      const pct = Math.round((e.loaded / e.total) * 100);\n      console.log('Upload progress:', `${pct}%`);\n    }\n  };\n\n  xhr.addEventListener('error', () => reject(new Error('Upload failed: network error')));\n  xhr.addEventListener('abort', () => reject(new Error('Upload aborted')));\n  xhr.addEventListener('loadend', () => {\n    const ok = xhr.readyState === 4 && xhr.status >= 200 && xhr.status < 300;\n    if (!ok) {\n      return reject(new Error(`Upload failed: HTTP ${xhr.status}`));\n    }\n    resolve();\n  });\n\n  xhr.open('PUT', uploadUrl, true);\n  xhr.setRequestHeader('Content-Type', file.type || 'application/octet-stream');\n\n  if (uploadExtraParams) {\n    Object.entries(uploadExtraParams).forEach(([key, value]) => {\n      xhr.setRequestHeader(key, String(value));\n    });\n  }\n\n  xhr.send(file);\n});\n"})}),"\n",(0,o.jsx)(n.h3,{id:"committing-to-an-existing-record-commiturltoupdateexistingrecord",children:"Committing to an existing record (commitUrlToUpdateExistingRecord)"}),"\n",(0,o.jsx)(n.p,{children:"From your backend API (called after the browser upload finishes):"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",metastring:'title="./index.ts"',children:"import type { IAdminUserExpressRequest } from 'adminforth';\nimport express from 'express';\n\n...\n\napp.post(\n  `${ADMIN_BASE_URL}/api/uploads/commit-existing`,\n  admin.express.authorize(async (req: IAdminUserExpressRequest, res: express.Response) => {\n    const { recordId, filePath } = req.body;\n\n    const plugin = admin.getPluginById('my_reports_plugin');\n\n    const adminUser = req.adminUser; // current admin user\n    // or if you are using non-adminforth handlers, e.g. public API\n    // adminUser: { isExternalUser: true, pk: null, dbUser: {}, username: 'empty' },\n\n    const { path, previewUrl } = await plugin.commitUrlToUpdateExistingRecord({\n      recordId,\n      filePath,\n      adminUser,\n      extra: req.extra, // optional HTTP context\n    });\n\n    res.json({ path, previewUrl });\n  }),\n);\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Or for custom non-authorized APIs (e.g. public API for external users), make sure to pass an ",(0,o.jsx)(n.code,{children:"adminUser"})," object with ",(0,o.jsx)(n.code,{children:"isExternalUser: true"})," to indicate that this is not a real admin user from your database:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",metastring:'title="./index.ts"',children:"...\napp.post(\n  `${ADMIN_BASE_URL}/api/uploads/commit-existing-public`,\n  async (req: express.Request, res: express.Response) => {\n    const { recordId, filePath } = req.body;\n\n    const plugin = admin.getPluginById('my_reports_plugin');\n\n    const adminUser = { isExternalUser: true, pk: null, dbUser: {}, username: 'empty' };\n    // or if you are using non-adminforth handlers, e.g. public API\n    // adminUser: { isExternalUser: true, pk: null, dbUser: {}, username: 'empty' },\n\n    const { path, previewUrl } = await plugin.commitUrlToUpdateExistingRecord({\n      recordId,\n      filePath,\n      adminUser,\n      extra: {}, // optional extra context\n    });\n\n    res.json({ path, previewUrl });\n  },\n);\n"})}),"\n",(0,o.jsxs)(n.p,{children:["This updates only the existing record (no new record is created) and replaces the value in ",(0,o.jsx)(n.code,{children:"pathColumnName"})," with ",(0,o.jsx)(n.code,{children:"filePath"}),". If the path is the same as the current value, an error is thrown to avoid caching issues."]}),"\n",(0,o.jsx)(n.h3,{id:"committing-and-creating-a-new-record-commiturltonewrecord",children:"Committing and creating a new record (commitUrlToNewRecord)"}),"\n",(0,o.jsx)(n.p,{children:"If you want the upload to create a new record:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",metastring:'title="./index.ts"',children:"import type { IAdminUserExpressRequest } from 'adminforth';\nimport express from 'express';\n\n...\n\napp.post(\n  `${ADMIN_BASE_URL}/api/uploads/commit-new`,\n  admin.express.authorize(async (req: IAdminUserExpressRequest, res: express.Response) => {\n    const { filePath, recordAttributes } = req.body;\n\n    const plugin = admin.getPluginById('my_reports_plugin');\n\n    const adminUser = req.adminUser; // current admin user\n    // or if you are using non-adminforth handlers, e.g. public API\n    // adminUser: { isExternalUser: true, pk: null, dbUser: {}, username: 'empty' },\n\n    const { path, previewUrl, newRecordPk } = await plugin.commitUrlToNewRecord({\n      filePath,\n      adminUser,\n      extra: req.extra,\n      recordAttributes, // e.g. { title: 'Generated report', listed: false }\n    });\n\n    res.json({ path, previewUrl, newRecordPk });\n  }),\n);\n"})}),"\n",(0,o.jsx)(n.p,{children:"This will:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["Mark the uploaded key as ",(0,o.jsx)(n.strong,{children:"not"})," a deletion candidate."]}),"\n",(0,o.jsxs)(n.li,{children:["Create a new record with ",(0,o.jsx)(n.code,{children:"pathColumnName"})," set to ",(0,o.jsx)(n.code,{children:"filePath"})," (plus any extra ",(0,o.jsx)(n.code,{children:"recordAttributes"}),")."]}),"\n",(0,o.jsxs)(n.li,{children:["Return both ",(0,o.jsx)(n.code,{children:"previewUrl"})," and the new record primary key."]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"uploading-to-one-field-from-another-custom-createedit-components",children:"Uploading to one field from another (custom create/edit components)"}),"\n",(0,o.jsx)(n.p,{children:"Sometimes you want to upload a file from one field (custom editor) but store the final path in another field that is handled by an Upload plugin instance. The recommended way is to:"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:["Call your backend to get a presigned URL via ",(0,o.jsx)(n.code,{children:"getUploadUrl"}),"."]}),"\n",(0,o.jsx)(n.li,{children:"Upload from the browser directly to storage."}),"\n",(0,o.jsxs)(n.li,{children:["Emit ",(0,o.jsx)(n.code,{children:"update:recordFieldValue"})," from the custom component with ",(0,o.jsx)(n.code,{children:"{ fieldName: pathColumnName, fieldValue: filePath }"})," so the other field is updated."]}),"\n"]}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsxs)(n.p,{children:["Note: if the target UploadPlugin column is hidden on the current page (",(0,o.jsx)(n.code,{children:"showIn.create: false"})," / ",(0,o.jsx)(n.code,{children:"showIn.edit: false"}),"), the backend rejects such updates by default.\nTo allow this, set the target column config to ",(0,o.jsx)(n.code,{children:"allowModifyWhenNotShowInCreate: true"})," and/or ",(0,o.jsx)(n.code,{children:"allowModifyWhenNotShowInEdit: true"}),"."]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"This lets you reuse the same Upload plugin instance (and its preview logic) while controlling the UX from a different field."}),"\n",(0,o.jsx)(n.p,{children:"Example Vue custom editor that uploads an avatar and writes the result into another field handled by Upload plugin:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-html",metastring:'title="./custom/AvatarUploader.vue"',children:"<template>\n  <div class=\"flex flex-col gap-2\">\n    <input type=\"file\" accept=\"image/*\" @change=\"onFileChange\" />\n    <img v-if=\"preview\" :src=\"preview\" class=\"w-16 h-16 rounded-full object-cover\" />\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport { ref } from 'vue';\n\nconst props = defineProps<{ record: any }>();\n\nconst emit = defineEmits([\n  'update:value',             // optional: current column value\n  'update:recordFieldValue',  // update another field in the record\n]);\n\nconst preview = ref<string | null>(null);\n\nasync function onFileChange(e: Event) {\n  const input = e.target as HTMLInputElement;\n  const file = input.files?.[0];\n  if (!file) return;\n\n  // 1) Ask backend for presigned URL\n  const { uploadUrl, filePath, uploadExtraParams, pathColumnName } = await fetch(\n    '/api/uploads/avatar/get-url',\n    {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({\n        recordId: props.record.id, // undefined for create\n        filename: file.name,\n        contentType: file.type,\n        size: file.size,\n      }),\n    },\n  ).then(r => r.json());\n\n  // 2) Direct upload to storage\n  await new Promise<void>((resolve, reject) => {\n    const xhr = new XMLHttpRequest();\n\n    xhr.upload.onprogress = (e) => {\n      if (e.lengthComputable) {\n        const pct = Math.round((e.loaded / e.total) * 100);\n        console.log('Upload progress:', `${pct}%`);\n      }\n    };\n\n    xhr.addEventListener('error', () => reject(new Error('Upload failed: network error')));\n    xhr.addEventListener('abort', () => reject(new Error('Upload aborted')));\n    xhr.addEventListener('loadend', () => {\n      const ok = xhr.readyState === 4 && xhr.status >= 200 && xhr.status < 300;\n      if (!ok) {\n        return reject(new Error(`Upload failed: HTTP ${xhr.status}`));\n      }\n      resolve();\n    });\n\n    xhr.open('PUT', uploadUrl, true);\n    xhr.setRequestHeader('Content-Type', file.type || 'application/octet-stream');\n\n    if (uploadExtraParams) {\n      Object.entries(uploadExtraParams).forEach(([key, value]) => {\n        xhr.setRequestHeader(key, String(value));\n      });\n    }\n\n    xhr.send(file);\n  });\n\n  // 3) Tell AdminForth to store filePath in the target field\n  emit('update:recordFieldValue', {\n    fieldName: pathColumnName, // target UploadPlugin field\n    fieldValue: filePath,\n  });\n\n  // optional local preview\n  preview.value = URL.createObjectURL(file);\n}\n<\/script>\n"})}),"\n",(0,o.jsxs)(n.p,{children:["On the backend, ",(0,o.jsx)(n.code,{children:"/api/uploads/avatar/get-url"})," can look like this:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",metastring:'title="./index.ts"',children:"import type { IAdminUserExpressRequest } from 'adminforth';\nimport express from 'express';\n\n...\n\napp.post(\n  `${ADMIN_BASE_URL}/api/uploads/avatar/get-url`,\n  admin.express.authorize(async (req: IAdminUserExpressRequest, res: express.Response) => {\n    const { recordId, filename, contentType, size } = req.body;\n\n    const plugin = admin.getPluginById('my_reports_plugin');\n\n    const { uploadUrl, filePath, uploadExtraParams, pathColumnName } = await plugin.getUploadUrl({\n      recordId, // can be undefined for create pages\n      filename,\n      contentType,\n      size, // optional\n    });\n\n    res.json({ uploadUrl, filePath, uploadExtraParams, pathColumnName });\n  }),\n);\n"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsxs)(n.p,{children:["\u26a0\ufe0f Do not call ",(0,o.jsx)(n.code,{children:"commitUrlToUpdateExistingRecord"})," or ",(0,o.jsx)(n.code,{children:"commitUrlToNewRecord"})," from the same resource\u2019s ",(0,o.jsx)(n.code,{children:"beforeSave"}),"/",(0,o.jsx)(n.code,{children:"afterSave"})," hooks, as it would create an infinite loop of updates/creates. These methods are intended to be called from your own API endpoints after the browser upload finishes."]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(c,{...e})}):c(e)}},28453:(e,n,r)=>{r.d(n,{R:()=>s,x:()=>a});var t=r(96540);const o={},i=t.createContext(o);function s(e){const n=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);